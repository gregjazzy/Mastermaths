generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String          @id @default(cuid())
  email                 String          @unique
  emailsNotification    String[]
  emailVerified         DateTime?
  hashedPassword        String?
  name                  String?
  status                UserStatus      @default(FREE)
  isSubscribed          Boolean         @default(false)
  stripeCustomerId      String?         @unique
  subscriptionId        String?
  currentTitle          String          @default("Apprenti Math√©maticien")
  totalMasteryPoints    Int             @default(0)
  monthlyMasteryPoints  Int             @default(0)
  weeklyMasteryPoints   Int             @default(0)
  lastMonthlyReset      DateTime?
  lastWeeklyReset       DateTime?
  currentStreak         Int             @default(0)
  longestStreak         Int             @default(0)
  lastConnectionDate    DateTime?       @db.Date
  totalConnectionTime   Int             @default(0)
  monthlyConnectionTime Int             @default(0)
  weeklyConnectionTime  Int             @default(0)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  accounts              Account[]
  connectionLogs        ConnectionLog[]
  masteryBadges         MasteryBadge[]
  performances          Performance[]
  sessions              Session[]
  user_badges           user_badges[]

  @@map("users")
}

model ConnectionLog {
  id              String   @id @default(cuid())
  userId          String
  connectionDate  DateTime @db.Date
  durationMinutes Int      @default(0)
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, connectionDate])
  @@map("connection_logs")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Course {
  id            String    @id @default(cuid())
  title         String
  description   String?
  order         Int       @default(0)
  isDemoContent Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  chapters      Chapter[]

  @@map("courses")
}

model Chapter {
  id                          String       @id @default(cuid())
  title                       String
  description                 String?
  order                       Int          @default(0)
  courseId                    String
  isDemoContent               Boolean      @default(false)
  mentalMapUrl                String?
  mentalMapTitle              String?
  mentalMapDescription        String?
  lyceesRepertoireUrl         String?
  lyceesRepertoireTitle       String?
  lyceesRepertoireDescription String?
  createdAt                   DateTime     @default(now())
  updatedAt                   DateTime     @updatedAt
  course                      Course       @relation(fields: [courseId], references: [id], onDelete: Cascade)
  subChapters                 SubChapter[]

  @@map("chapters")
}

model SubChapter {
  id            String   @id @default(cuid())
  title         String
  description   String?
  order         Int      @default(0)
  chapterId     String
  isDemoContent Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lessons       Lesson[]
  chapter       Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  @@map("subchapters")
}

model Lesson {
  id                String        @id @default(cuid())
  title             String
  subChapterId      String
  type              LessonType
  contentUrl        String?
  isDemoContent     Boolean       @default(false)
  countForReporting Boolean       @default(true)
  isOptional        Boolean       @default(false)
  order             Int           @default(0)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  exercises         Exercise[]
  subChapter        SubChapter    @relation(fields: [subChapterId], references: [id], onDelete: Cascade)
  performances      Performance[]
  qcmQuestions      QcmQuestion[] @relation("LessonQcm")

  @@map("lessons")
}

model Exercise {
  id                    String        @id @default(cuid())
  title                 String
  lessonId              String
  order                 Int           @default(0)
  isDemoContent         Boolean       @default(false)
  exerciseUrl           String?
  correctionVideoUrl    String?
  correctionDocumentUrl String?
  createdAt             DateTime      @default(now()) @db.Timestamp(6)
  updatedAt             DateTime      @default(now()) @updatedAt @db.Timestamp(6)
  lesson                Lesson        @relation(fields: [lessonId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  performances          Performance[]
  qcmQuestions          QcmQuestion[] @relation("ExerciseQcm")

  @@index([lessonId])
  @@map("exercises")
}

model QcmQuestion {
  id               String    @id @default(cuid())
  lessonId         String?
  question         String
  options          String[]
  correctAnswer    Int?
  correctAnswers   Int[]
  isMultipleChoice Boolean   @default(false)
  explanation      String?
  order            Int       @default(0)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  exerciseId       String?
  exercise         Exercise? @relation("ExerciseQcm", fields: [exerciseId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  lesson           Lesson?   @relation("LessonQcm", fields: [lessonId], references: [id], onDelete: Cascade)

  @@index([exerciseId])
  @@map("qcm_questions")
}

model Performance {
  id                   String    @id @default(cuid())
  userId               String
  lessonId             String?
  videoProgressPercent Float     @default(0)
  quizScorePercent     Float?
  isCompleted          Boolean   @default(false)
  hasViewedCorrection  Boolean   @default(false)
  lastAccessedAt       DateTime  @default(now())
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  exerciseId           String?
  exercises            Exercise? @relation(fields: [exerciseId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  lesson               Lesson?   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, lessonId])
  @@index([exerciseId])
  @@map("performances")
}

model Badge {
  id                    String        @id @default(cuid())
  name                  String
  description           String
  icon                  String
  rarity                String
  masteryPointsRequired Int           @default(0)
  createdAt             DateTime      @default(now())
  masteryPoints         Int           @default(0)
  order                 Int           @default(0)
  criteria              Json?
  user_badges           user_badges[]

  @@map("badges")
}

model user_badges {
  id         String   @id
  userId     String
  badgeId    String
  unlockedAt DateTime @default(now())
  badges     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  users      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
}

model verification_tokens {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model MasteryBadge {
  id         String   @id @default(dbgenerated("(gen_random_uuid())::text"))
  userId     String
  type       String
  level      String
  entityId   String
  entityName String
  score      Int?
  pmuAwarded Int
  earnedAt   DateTime @default(now()) @db.Timestamp(6)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "mastery_badges_userid_fkey")

  @@unique([userId, type, entityId, level], map: "mastery_badges_unique")
  @@index([userId], map: "mastery_badges_userid_idx")
  @@map("mastery_badges")
}

enum UserStatus {
  FREE
  DEMO
  PREMIUM
}

enum LessonType {
  VIDEO_COURS
  QCM
  CORRECTION_VIDEO
  CORRECTION_DOCUMENT
  EXO_ECRIT
  DS
  CARTOGRAPHIE
  METHODE
}
