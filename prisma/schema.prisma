generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String          @id @default(cuid())
  email                 String          @unique
  emailsNotification    String[]
  emailVerified         DateTime?
  hashedPassword        String?
  name                  String?
  status                UserStatus      @default(FREE)
  isSubscribed          Boolean         @default(false)
  stripeCustomerId      String?         @unique
  subscriptionId        String?
  currentTitle          String          @default("Apprenti Mathématicien")
  totalMasteryPoints    Int             @default(0)
  monthlyMasteryPoints  Int             @default(0)
  weeklyMasteryPoints   Int             @default(0)
  lastMonthlyReset      DateTime?
  lastWeeklyReset       DateTime?
  currentStreak         Int             @default(0)
  longestStreak         Int             @default(0)
  lastConnectionDate    DateTime?       @db.Date
  totalConnectionTime   Int             @default(0)
  monthlyConnectionTime Int             @default(0)
  weeklyConnectionTime  Int             @default(0)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  accounts              Account[]
  connectionLogs        ConnectionLog[]
  performances          Performance[]
  sessions              Session[]
  user_badges           user_badges[]
  masteryBadges         MasteryBadge[]

  @@map("users")
}

model ConnectionLog {
  id              String   @id @default(cuid())
  userId          String
  connectionDate  DateTime @db.Date
  durationMinutes Int      @default(0)
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, connectionDate])
  @@map("connection_logs")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Course {
  id            String    @id @default(cuid())
  title         String
  description   String?
  order         Int       @default(0)
  isDemoContent Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  chapters      Chapter[]

  @@map("courses")
}

model Chapter {
  id                          String       @id @default(cuid())
  title                       String
  description                 String?
  order                       Int          @default(0)
  courseId                    String
  mentalMapUrl                String?
  mentalMapTitle              String?
  mentalMapDescription        String?
  lyceesRepertoireUrl         String?
  lyceesRepertoireTitle       String?
  lyceesRepertoireDescription String?
  createdAt                   DateTime     @default(now())
  updatedAt                   DateTime     @updatedAt
  course                      Course       @relation(fields: [courseId], references: [id], onDelete: Cascade)
  subChapters                 SubChapter[]

  @@map("chapters")
}

model SubChapter {
  id          String   @id @default(cuid())
  title       String
  description String?
  order       Int      @default(0)
  chapterId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lessons     Lesson[]
  chapter     Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  @@map("subchapters")
}

model Lesson {
  id                                         String        @id @default(cuid())
  title                                      String
  subChapterId                               String
  type                                       LessonType
  contentUrl                                 String?
  isCorrectionVideo                          Boolean       @default(false)
  isCorrectionDocument                       Boolean       @default(false)
  linkedQcmId                                String?
  linkedExerciseId                           String?
  prerequisiteLessonId                       String?
  parentLessonId                             String?
  countForReporting                          Boolean       @default(true)
  isOptional                                 Boolean       @default(false)
  order                                      Int           @default(0)
  createdAt                                  DateTime      @default(now())
  updatedAt                                  DateTime      @updatedAt
  linkedExercise                             Lesson?       @relation("ExerciseCorrection", fields: [linkedExerciseId], references: [id])
  corrections                                Lesson[]      @relation("ExerciseCorrection")
  lessons_lessons_linkedQcmIdTolessons       Lesson?       @relation("lessons_linkedQcmIdTolessons", fields: [linkedQcmId], references: [id])
  other_lessons_lessons_linkedQcmIdTolessons Lesson[]      @relation("lessons_linkedQcmIdTolessons")
  parentLesson                               Lesson?       @relation("LessonHierarchy", fields: [parentLessonId], references: [id])
  childLessons                               Lesson[]      @relation("LessonHierarchy")
  prerequisiteLesson                         Lesson?       @relation("LessonPrerequisite", fields: [prerequisiteLessonId], references: [id])
  dependentLessons                           Lesson[]      @relation("LessonPrerequisite")
  subChapter                                 SubChapter    @relation(fields: [subChapterId], references: [id], onDelete: Cascade)
  performances                               Performance[]
  qcmQuestions                               QcmQuestion[]

  @@index([linkedExerciseId], map: "Lesson_linkedExerciseId_idx")
  @@index([parentLessonId], map: "Lesson_parentLessonId_idx")
  @@index([prerequisiteLessonId], map: "Lesson_prerequisiteLessonId_idx")
  @@map("lessons")
}

model QcmQuestion {
  id               String   @id @default(cuid())
  lessonId         String
  question         String
  options          String[]
  correctAnswer    Int?
  correctAnswers   Int[]
  isMultipleChoice Boolean  @default(false)
  explanation      String?
  order            Int      @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  lesson           Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  @@map("qcm_questions")
}

model Performance {
  id                   String   @id @default(cuid())
  userId               String
  lessonId             String
  videoProgressPercent Float    @default(0)
  quizScorePercent     Float?
  isCompleted          Boolean  @default(false)
  hasViewedCorrection  Boolean  @default(false)
  lastAccessedAt       DateTime @default(now())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  lesson               Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, lessonId])
  @@map("performances")
}

model Badge {
  id                    String        @id @default(cuid())
  name                  String
  description           String
  icon                  String
  rarity                String
  masteryPointsRequired Int           @default(0)
  masteryPoints         Int           @default(0)
  order                 Int           @default(0)
  criteria              Json?
  createdAt             DateTime      @default(now())
  user_badges           user_badges[]

  @@map("badges")
}

model user_badges {
  id         String   @id
  userId     String
  badgeId    String
  unlockedAt DateTime @default(now())
  badges     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  users      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
}

model verification_tokens {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserStatus {
  FREE
  DEMO
  PREMIUM
}

enum LessonType {
  VIDEO_COURS
  QCM
  CORRECTION_VIDEO
  CORRECTION_DOCUMENT
  EXO_ECRIT
  DS
  CARTOGRAPHIE
  METHODE
}

model MasteryBadge {
  id          String   @id @default(cuid())
  userId      String
  type        String   // 'LESSON', 'CHAPTER', 'COURSE'
  level       String   // 'BRONZE', 'SILVER', 'GOLD', 'COMPLETED', 'MASTERED', 'GRADUATE', 'EXCELLENCE'
  entityId    String   // ID de la leçon, chapitre ou cours
  entityName  String   // Nom pour affichage
  score       Int?     // Score du QCM (pour les badges de leçon)
  pmuAwarded  Int      // PMU gagnés pour ce badge
  earnedAt    DateTime @default(now())
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, type, entityId, level]) // Un badge unique par combinaison
  @@map("mastery_badges")
}
